{

import "package:parser_peg/src/node.dart";
import "package:parser_peg/src/generator.dart";
import "package:parser_peg/src/statement.dart";

final _regexps = (
  from: RegExp(r"\bfrom\b"),
  to: RegExp(r"\bto\b"),
);

}

/// A grammar file contains an optional preamble and statements.
ParserGenerator document = ^ :preamble? statements:_..statement+ _? $ {
  ParserGenerator.fromParsed(preamble: preamble, statements: statements)
};


/// The preamble is simple.
String preamble = `{` _ code:code.curly _ `}` { code };

/// A statement can either be a namespace, a fragment or a rule.
///  A namespace is a collection of statements.
///  A fragment is a declaration that is faster, but doesn't support left recursion / memoization.
///  A rule is a declaration, that supports left recursion & memoization.
Statement statement =
  | namespace
  | fragment
  | inline
  | rule
  ;

@fragment {
  String namespaceReference = (identifier ("::" | !".." ".") !mac @0)* { $.join("::") };
  String namespacedRaw = namespaceReference literal.raw { $0.isEmpty ? $1 : "${$0}::${$1}" };
  String namespacedIdentifier = namespaceReference identifier { $0.isEmpty ? $1 : "${$0}::${$1}" };

  String name = namespacedRaw | namespacedIdentifier;

  Node body = `=` :choice `;` { choice };
}

/// A namespace is a block of statements which can apply a tag and/or be encapsulated
///   under a name.
Statement namespace =
  | kw.decorator.fragment name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.fragment)
    }
  | kw.decorator.rule name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.rule)
    }
  | kw.decorator.inline name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.inline)
    }
  | name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: null)
    }
  ;


/// A rule is a declaration that supports left recursion & memoization.
/// It can be explicitly stated with a `@rule` keyword, but it is not necessary.
/// It can, however, be useful if it is used inside a `@fragment` tagged namespace.
Statement rule =
  | kw.decorator.rule? kw.var :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  ;

/// A fragment is a declaration that is called directly, meaning not supporting left recursion / memoization.
/// It can be explicitly stated with a `@fragment` keyword.
Statement fragment =
  | kw.decorator.fragment kw.var :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  ;

/// An inline is a declaration that is inlined in the grammar when possible.
/// It can be explicitly stated with a `@inline` keyword.
Statement inline =
  | kw.decorator.inline kw.var :name :body {
      DeclarationStatement(null, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline :name :body {
      DeclarationStatement(null, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: Tag.inline)
    }
  ;

/// A choice parser is a parser that tries to match one of the options.
/// Despite the syntax, the parser is ordered choice.
Node choice = `|`? options:`|`..acted { options.length == 1 ? options.single : ChoiceNode(options) };

/// A parser with a bound action.
Node acted =
  /// An empty inline action means that the parser will only return the recognized substring.
  | :sequence `{` `}` {
      InlineActionNode(
        sequence,
        "this.buffer.substring(from, to)",
        areIndicesProvided: true,
      )
    }
  | :sequence `{` _ :code.curly _ `}` {
      InlineActionNode(
        sequence,
        curly.trimRight(),
        areIndicesProvided: curly.contains(_regexps.from) && curly.contains(_regexps.to),
      )
    }
  | :sequence `(` `)` `{` _ :code.curly _ `}` {
      ActionNode(
        sequence,
        curly.trimRight(),
        areIndicesProvided: curly.contains(_regexps.from) && curly.contains(_regexps.to),
      )
    }
  | sequence
  ;

/// A parser that parses a sequence of parsers.
///   By default, a sequence parser returns a [Record] of the results of the parsers.
Node sequence =
  /// By specifying which item to keep, the specific item can be returned.
  | body:_..dropped+ `@` :number { body.length == 1 ? body.single : SequenceNode(body, choose: number) }
  | _..dropped+ { $.length == 1 ? $.single : SequenceNode($, choose: null) }
  ;

Node dropped =
  | labeled
  ;

/// A parser that adds the label to the declaration of the value.
Node labeled =
  /// The default label. You can label any expression by adding a colon and an identifier.
  /// The label must not have a space before the colon.
  | :identifier ":" _ :special { NamedNode(identifier, special) }

  /// Special cases, where the name can be inferred from the context.
  | ":" id:namespacedIdentifier `?` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, OptionalNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier `*` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, StarNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier `+` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, PlusNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, ReferenceNode(ref)),
      _ => null,
    } }
  /// Fallback
  | special
  ;

Node special =
  /// Parsers with a specific count.
  | min:number `..` max:number? :macro { CountedNode(min, max, macro) }
  | :number :macro                     { CountedNode(number, number, macro) }
  /// Pegen style separators.
  | sep:callLike `..` expr:callLike `+`? { PlusSeparatedNode(sep, expr, isTrailingAllowed: false) }
  | sep:callLike `..` expr:callLike `*`  { StarSeparatedNode(sep, expr, isTrailingAllowed: false) }
  | postfix
  ;

/// A parser that is quantified.
///   Can be nested, but shouldn't be used in practice.
Node postfix =
  | postfix `?` @0 { OptionalNode($) }
  | postfix `*` @0 { StarNode($) }
  | postfix `+` @0 { PlusNode($) }
  | prefix
  ;

/// A parser that is prefixed.
///   Usually with disambiguators such as `and-predicate` and `not-predicate`.
Node prefix =
  | `~` prefix @1 { SequenceNode([NotPredicateNode($), const AnyCharacterNode()], choose: 1) }
  | `&` prefix @1 { AndPredicateNode($) }
  | `!` prefix @1 { NotPredicateNode($) }
  | callLike
  ;

/// "Call"-like because they technically look like a call, but this is special syntax.
///   (Calls don't exist.)
Node callLike =
  /// Flattens a parser result.
  ///   a.flat!()
  | target:callLike DOT mac.flat `(`  `)` {
      InlineActionNode(target, "this.buffer.substring(from, to)", areIndicesProvided: true)
    }
  /// Expects a number of results.
  ///  a.range!(2, 4)
  ///  a.range!(2)
  ///  a.range! 2
  | target:callLike DOT mac.range `(` min:number `,` max:number `)` { CountedNode(min, max, target) }
  | target:callLike DOT mac.range `(` :number `)`                   { CountedNode(number, number, target) }
  | target:callLike DOT mac.range  _  :number  _                    { CountedNode(number, number, target) }
  /// Separates a parser by a separator.
  ///  a.sep! b
  | sep:callLike DOT mac.sep `(` body:choice `)` `+` `?` { PlusSeparatedNode(sep, body, isTrailingAllowed: true)  }
  | sep:callLike DOT mac.sep `(` body:choice `)` `*` `?` { StarSeparatedNode(sep, body, isTrailingAllowed: true)  }
  | sep:callLike DOT mac.sep `(` body:choice `)` `+`     { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike DOT mac.sep `(` body:choice `)` `*`     { StarSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike DOT mac.sep `(` body:choice `)`         { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike DOT mac.sep  _  body:macro   _          { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | macro
  ;


/// Parsers that look like macro invocations.
/// Must be delimited.
Node macro =
  /// Macro flat.
  /// flat!{ expr }
  | mac.flat `{` body:choice `}` {
      InlineActionNode(body, "this.buffer.substring(from, to)", areIndicesProvided: true)
    }
  /// Macro ranges.
  /// range!(2, 4) { expr }
  /// range!(2, .) { expr }
  /// range!(2) { expr }
  | mac.range `(` min:number `,` max:number `)` `{` body:choice `}` { CountedNode(min, max, body)       }
  | mac.range `(` min:number `,` `.` `)` `{` body:choice `}`        { CountedNode(min, null, body)      }
  | mac.range `(` :number `)` `{` body:choice `}`                   { CountedNode(number, number, body) }
  /// Macro style separators.
  /// sep!{"," => expr}
  | mac.sep `(` `+` `?` `)` `{` sep:macro `=>` body:macro `}` { PlusSeparatedNode(sep, body, isTrailingAllowed: true) }
  | mac.sep `(` `*` `?` `)` `{` sep:macro `=>` body:macro `}` { StarSeparatedNode(sep, body, isTrailingAllowed: true) }
  | mac.sep `(` `+` `)` `{` sep:macro `=>` body:macro `}`    { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | mac.sep `(` `*` `)` `{` sep:macro `=>` body:macro `}`    { StarSeparatedNode(sep, body, isTrailingAllowed: false) }
  | mac.sep `{` sep:macro `=>` body:macro `}`                { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | atom
  ;

/// A parser that can be qualified as a group.
///   These are usually parsers that are delimited.
Node atom =
  /// Basic atomic parsers.
  | `(` choice `)` @1
  /// Special syntax for character classes.
  | (CARET   | kw.start)     { const StartOfInputNode() }
  | (DOLLAR  | kw.end)       { const EndOfInputNode() }
  | (DOT     | kw.any)       { const AnyCharacterNode() }
  | (EPSILON | kw.epsilon)   { const EpsilonNode() }
  /// TODO: Add regex backslash symbols.
  | regexEscape.backslash { const StringLiteralNode(r"\") }
  | regexEscape.digit     { SimpleRegExpEscapeNode.digit }
  | regexEscape.space     { SimpleRegExpEscapeNode.whitespace }
  /// Basic literals.
  | literal.range
  | literal.regexp { RegExpNode($) }
  | literal.string { StringLiteralNode($) }
  | name           { ReferenceNode($) }
  ;

code {
  String curly =
    | "`" ~"`"* "`" @1 { $.join() }
    | curly.balanced
    ;

  curly {
    String balanced = code:(
        | dart.literal.string
        | "{" balanced "}" @1 {"{" + $ + "}"}
        | ~("{" | "}")
      )* { code.join() };
  }
}

@fragment literal {
  String regexp = "/" ((\\ . @1 { r"\" + $ } | ~"/")+ { $.join() } ) "/" @1;
  String string = _ string.main _ @1;
  string {
    @inline String main =
      /// Raw string literals
      | 'r"""' ~'"""'* '"""' @1 { $.join() }
      | "r'''" ~"'''"* "'''" @1 { $.join() }
      | 'r"'   ~'"'*   '"'   @1 { $.join() }
      | "r'"   ~"'"*   "'"   @1 { $.join() }
      /// Escaped string literals
      | '"""' (\\ . @1 | ~'"""')* '"""' @1 { $.join() }
      | "'''" (\\ . @1 | ~"'''")* "'''" @1 { $.join() }
      | '"'   (\\ . @1 | ~'"'  )* '"'   @1 { $.join() }
      | "'"   (\\ . @1 | ~"'"  )* "'"   @1 { $.join() }
      ;
  }

  Node range =  _ range.main _ @1;
  range {
    @inline Node main = _ "[" elements:_..element+ "]" _ { RangeNode(elements.reduce((a, b) => a.union(b))) };
    Set<(int, int)> element =
      | escape
      | l:atom "-" r:atom { {(l.codeUnitAt(0), r.codeUnitAt(0))} }
      | atom              { {($.codeUnitAt(0), $.codeUnitAt(0))} }
      ;

    @inline Set<(int, int)> escape =
      | " " { {(32, 32)} } // " "
      | \\ r"d" { {(48, 57)} } // 0-9
      | \\ r"w" { {(64 + 1, 64 + 26), (96 + 1, 96 + 26)} } // a-z, A-Z
      | \\ r"s" { {(9, 13), (32, 32)} } // \t, \n, \r, \f, \v, space
      | regexEscape.newline { {(10, 10)} }
      | regexEscape.carriageReturn { {(13, 13)} }
      | regexEscape.tab { {(9, 9)} }
      | regexEscape.backslash { {(92, 92)} }
      ;
    String atom = \\ . @1 | ~"]";
  }

  String raw = "`" ~"`"* "`"  @1 { $.join() };
}

/// Rules related to [Dart] expressions.
dart {
  literal {
    /// Since string literals in [Dart] can be put adjacent, we need to parse while
    ///   there are still string literals.
    String string = _..string.main.flat!()+ { $.join() };
    String identifier = global.identifier.flat!();

    string {
      @inline main = (
        /// Raw string literals
        | "r" '"""' ~'"""'* '"""' { () }
        | "r" "'''" ~"'''"* "'''" { () }
        | "r" '"'   ~'"'*   '"'   { () }
        | "r" "'"   ~"'"*   "'"   { () }
        /// Escaped string literals
        | '"""' (\\ . @1 | &"$" interpolation | ~'"""')* '"""' { () }
        | "'''" (\\ . @1 | &"$" interpolation | ~"'''")* "'''" { () }
        | '"'   (\\ . @1 | &"$" interpolation | ~'"'  )* '"'   { () }
        | "'"   (\\ . @1 | &"$" interpolation | ~"'"  )* "'"   { () }
      )*;

      Object interpolation =
        | r"$" "{" balanced "}"
        | r"$" identifier
        ;
      Object balanced = code:("{" balanced "}" @1 | ~("{" | "}"))*;
    }
  }
}

/// Rules related to types declarations.
type {
  String main        = _ raw _ @1 | nonNullable;
  String nullable    = _ :nonNullable _ `?`? { $3 == null ? "$nonNullable" : "$nonNullable?" };
  String nonNullable = _ (generic | record | base) _ @1;

  /// A record type.
  ///   The fields can be positional or named.
  ///   The fields are special by commas.
  String record =
    | `(` (`{` fields.named `}` @1)? `)` {
        "(" + ($1 == null ? "" : "{" + $1 + "}") + ")"
      }
    | `(` field.positional `,` (`{` fields.named `}` @1)? `)` {
        "(" + $1 + ", " + ($3 == null ? "" : "{" + $3 + "}") + ")"
      }
    | `(` fields.positional (`,` `{` fields.named `}` @2)? `)` {
        "(" + $1 + ($2 == null ? "" : ", {" + $2 + "}") + ")"
      }
    ;

  @inline {
    String generic   = :base `<` :arguments `>` { "$base<$arguments>" };
    String arguments = `,`..nullable+   { $.join(", ") };
    String base      = DOT..identifier+ { $.join(".") };
  }

  @fragment fields {
    String positional = `,`..field.positional+ { $.join(", ") };
    String named      = `,`..field.named+      { $.join(", ") };
  }

  @inline field {
    String positional = nullable _ identifier? { "${$0} ${$2 ?? ""}".trimRight() };
    String named      = nullable _ identifier  { "${$0} ${$2}" };
  }
}

/// Tokens used in the grammar.
///   Since they are not recursive, they are not defined as rules.
@fragment {
  String identifier = [a-zA-Z_$][a-zA-Z0-9_$]* { $0 + $1.join() };
  String raw = "`" ~"`"* "`" @1 { $.join() };
  int number = \d+ { int.parse($.join()) };

  kw {
    decorator {
      String rule      = _ "@rule" _        @1;
      String fragment  = _ "@fragment" _    @1;
      String inline    = _ "@inline" _      @1;
    }

    String start     = _ "startOfInput" _ @1;
    String end       = _ "endOfInput" _   @1;
    String backslash = _ "backslash" _    @1;
    String epsilon   = _ "epsilon" _      @1;
    String any       = _ "any" _          @1;
    String var       = _ "var" _          @1;
  }

  String mac =
    | mac.range
    | mac.flat
    | mac.sep
    ;
  /// Tokens used in "macro-like" rules.
  mac {
    String range = _ "range!" _ @1;
    String flat  = _ "flat!"  _ @1;
    String sep   = _ "sep!"   _ @1;
  }

  regexEscape {
    String backslash       = _ (\\ r"\").flat!() _ @1;
    String digit           = _ (\\ r"d").flat!() _ @1;
    String word            = _ (\\ r"w").flat!() _ @1;
    String space           = _ (\\ r"s").flat!() _ @1;
    String newline         = _ (\\ r"n").flat!() _ @1;
    String carriageReturn  = _ (\\ r"r").flat!() _ @1;
    String tab             = _ (\\ r"t").flat!() _ @1;
    String formFeed        = _ (\\ r"f").flat!() _ @1;
    String verticalTab     = _ (\\ r"v").flat!() _ @1;
    String null            = _ (\\ r"0").flat!() _ @1;
    String control         = _ (\\ r"c").flat!() _ @1;
    String hex             = _ (\\ r"x").flat!() _ @1;
    String unicode         = _ (\\ r"u").flat!() _ @1;
    String unicodeExtended = _ (\\ r"U").flat!() _ @1;
    String literal         = _ (\\ r".").flat!() _ @1;
  }

  /// Literal tokens
  String `..`  = _ ".." _ @1;
  String `::`  = _ "::" _ @1;
  String `%%`  = _ "%%" _ @1;
  String `=>`  = _ "=>" _ @1;
  String `->`  = _ "->" _ @1;

  String `%`   = _ "%"  _ @1;
  String `@`   = _ "@"  _ @1;
  String `<`   = _ "<"  _ @1;
  String `>`   = _ ">"  _ @1;
  String `]`   = _ "]"  _ @1;
  String `[`   = _ "["  _ @1;
  String `}`   = _ "}"  _ @1;
  String `{`   = _ "{"  _ @1;
  String `)`   = _ ")"  _ @1;
  String `(`   = _ "("  _ @1;
  String `;`   = _ ";"  _ @1;
  String `=`   = _ "="  _ @1;
  String `?`   = _ "?"  _ @1;
  String `!`   = _ "!"  _ @1;
  String `~`   = _ "~"  _ @1;
  String `&`   = _ "&"  _ @1;
  String `*`   = _ "*"  _ @1;
  String `+`   = _ "+"  _ @1;
  String `,`   = _ ","  _ @1;
  String `:`   = _ ":"  _ @1;
  String `|`   = _ "|"  _ @1;
  String `/`   = _ "/"  _ @1;

  String `.` = _ "."  _ @1;
  String `ε` = _ "ε"  _ @1;
  String `^` = _ "^"  _ @1;
  String `$` = _ "$"  _ @1;

  @inline {
    DOT = `.`;
    EPSILON = `ε`;
    CARET = `^`;
    DOLLAR = `$`;
  }

  /// Layout parser allows comments (like this) and space between parsers.
  /// Regular Expression monster:
  ///   Split into three parts.
  ///   1. `(?:\s)` - Matches any whitespace character.
  ///   2. `(?:\/{2}.*(?:(?:\r?\n)|(?:$)))` - Matches a single line comment.
  ///   3. `(?:\/\*(?:(?!\*\/).)*\*\/)` - Matches a multi-line comment.
  String _ = /(?:(?:\s)|(?:\/{2}.*(?:(?:\r?\n)|(?:$)))|(?:\/\*(?:(?!\*\/).)*\*\/))*/ { "" };
}
