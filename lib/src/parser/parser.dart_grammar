{
import "package:parser_peg/src/node.dart";
import "package:parser_peg/src/generator.dart";
import "package:parser_peg/src/statement.dart";
}

/// A grammar file contains an optional preamble and statements.
ParserGenerator document = ^ :preamble? statements:_.statement+? $ {
  ParserGenerator.fromParsed(preamble: preamble, statements: statements)
};

/// The preamble is simple.
String preamble = `{` _ code:code::curly _ `}` { code };

/// A statement can either be a namespace, a fragment or a rule.
///  A namespace is a collection of statements.
///  A fragment is a declaration that is faster, but doesn't support left recursion / memoization.
///  A rule is a declaration, that supports left recursion & memoization.
Statement statement =
  | namespace
  | fragment
  | rule;

@fragment
String name =
  | (identifier "::" @0)* literal::raw { $0.isEmpty ? $1 : "${$0.join("::")}::${$1}" }
  | identifier ("::" identifier @1)*   { $1.isEmpty ? $0 : "${$0}::${$1.join("::")}" };

@fragment
Node body = `=` :choice `;` { choice };

Statement namespace =
  | kw::fragment name:identifier? `{` statements:_.statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.fragment)
    }
  | kw::rule name:identifier? `{` statements:_.statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.rule)
    }
  | name:identifier? `{` statements:_.statement+ `}` {
      NamespaceStatement(name, statements, tag: null)
    }
  ;

Statement rule =
  | kw::rule? kw::var :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw::rule? :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw::rule? type:(type::main) :name :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw::rule? :name `:` type:(type::main) :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  ;

Statement fragment =
  | kw::fragment kw::var :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw::fragment :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw::fragment type:(type::main) :name :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  | kw::fragment :name `:` type:(type::main) :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  ;

Node choice = `|`? options:`|`.acted+ { options.length == 1 ? options.single : ChoiceNode(options) };

/// A parser with a bound action.
Node acted =
  /// Dart code action
  | :sequence `(` `)` `{` _ code:code::curly _ `}`  { ActionNode(sequence, code, areIndicesProvided: true) }
  | :sequence         `{` _ code:code::curly _ `}`  { InlineActionNode(sequence, code, areIndicesProvided: true ) }
  | sequence
  ;

/// A parser that parses a sequence of parsers.
///   By default, a sequence parser returns a [Record] of the results of the parsers.
Node sequence =
  /// By specifying which item to keep, the specific item can be returned.
  | body:_.labeled+ `@` :number { body.length == 1 ? body.single : SequenceNode(body, choose: number) }
  | _.labeled+ { $.length == 1 ? $.single : SequenceNode($, choose: null) }
  ;

/// A parser that adds the label to the declaration of the value.
Node labeled =
  /// The default label. You can label any expression by adding a colon and an identifier.
  /// The label must not have a space before the colon.
  | :identifier ":" _ :separated { NamedNode(identifier, separated) }

  /// Special cases, where the name can be inferred from the context.
  | ":" identifier `?` { NamedNode($1, OptionalNode(ReferenceNode($1))) }
  | ":" identifier `*` { NamedNode($1, StarNode(ReferenceNode($1))) }
  | ":" identifier `+` { NamedNode($1, PlusNode(ReferenceNode($1))) }
  | ":" identifier     { NamedNode($1, ReferenceNode($1)) }
  /// Fallback
  | separated
  ;

/// A parser that is separated by a separator.
///   For ambiguity, both the separator and the body must be an atomic parser.
Node separated =
  /// Parsers with a specific count.
  | min:number `..` max:number? :atom { CountedNode(min, max, atom) }
  | :number :atom                     { CountedNode(number, number, atom) }
  /// Pegen style separators.
  | sep:atom DOT expr:atom `+` trailing:`?`? { PlusSeparatedNode(sep, expr, isTrailingAllowed: trailing != null) }
  | sep:atom DOT expr:atom `*` trailing:`?`? { StarSeparatedNode(sep, expr, isTrailingAllowed: trailing != null) }
  | postfix
  ;

/// A parser that is quantified.
///   Can be nested, but shouldn't be used in practice.
Node postfix =
  | postfix `?` @0 { OptionalNode($) }
  | postfix `*` @0 { StarNode($) }
  | postfix `+` @0 { PlusNode($) }
  | prefix
  ;

/// A parser that is prefixed.
///   Usually with disambiguators such as `and-predicate` and `not-predicate`.
Node prefix =
  | `&` prefix @1 { AndPredicateNode($) }
  | `!` prefix @1 { NotPredicateNode($) }
  | atom
  ;

/// A parser that can be qualified as a group.
///   These are usually parsers that are delimited.
Node atom =
  /// "Macro" style separators.
  | mac::sep `(` `+` `?` `)` `{` sep:atom _ body:atom `}` {
      PlusSeparatedNode(sep, body, isTrailingAllowed: true)
    }
  | mac::sep `(` `*` `?` `)` `{` sep:atom _ body:atom `}` {
      StarSeparatedNode(sep, body, isTrailingAllowed: true)
    }
  | mac::sep `(` `+` `)` `{` sep:atom _ body:atom `}` {
      PlusSeparatedNode(sep, body, isTrailingAllowed: false)
    }
  | mac::sep `(` `*` `)` `{` sep:atom _ body:atom `}` {
      StarSeparatedNode(sep, body, isTrailingAllowed: false)
    }
  | mac::sep `{` sep:atom _ body:atom `}` { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  /// Basic atomic parsers.
  | `(` choice `)` @1
  | specialSymbol
  | literal::range
  | literal::regexp { RegExpNode(RegExp($)) }
  | literal::string { StringLiteralNode($) }
  | name            { ReferenceNode($) }
  ;

/// A special parser with their own syntax.
Node specialSymbol =
  | (CARET     | kw::start)     { const StartOfInputNode() }
  | (DOLLAR    | kw::end)       { const EndOfInputNode() }
  | (DOT       | kw::any)       { const AnyCharacterNode() }
  | (EPSILON   | kw::epsilon)   { const EpsilonNode() }
  // TODO: Add regex backslash symbols.
  | regexEscape::backslash { const StringLiteralNode(r"\") }
  | regexEscape::digit     { SimpleRegExpEscapeNode.digit }
  | regexEscape::space     { SimpleRegExpEscapeNode.whitespace }
  ;

code {
  String curly =
    | "`" inner:(!"`" . @1)* "`" { inner.join() }
    | balanced;
  String balanced = code:(
      | dart::literal::string
      | "{" balanced "}" @1 {"{" + $ + "}"}
      | !"{" !"}" . @2
    )* { code.join() };
}

@fragment literal {
  regexp = "/" ((\\ . @1 { r"\" + $ } | !"/" . @1)+ { $.join() } ) "/" @1;
  string = _ string::main _ @1;
  string {
    main =
      /// Raw string literals
      | "r" '"""' body:(!'"""' . @1)* '"""' { body.join() }
      | "r" "'''" body:(!"'''" . @1)* "'''" { body.join() }
      | "r" '"'   body:(!'"'   . @1)* '"'   { body.join() }
      | "r" "'"   body:(!"'"   . @1)* "'"   { body.join() }
      /// Escaped string literals
      | '"""' body:(\\ . @1 | !'"""' . @1)* '"""' { body.join() }
      | "'''" body:(\\ . @1 | !"'''" . @1)* "'''" { body.join() }
      | '"'   body:(\\ . @1 | !'"'   . @1)* '"'   { body.join() }
      | "'"   body:(\\ . @1 | !"'"   . @1)* "'"   { body.join() }
      ;
  }

  range =  _ range::main _ @1;
  range {
    main = `[` elements:_.element+ `]` { RangeNode(elements.reduce((a, b) => a.union(b))) };
    element =
      | escape
      | l:atom "-" r:atom { {(l.codeUnitAt(0), r.codeUnitAt(0))} }
      | atom              { {($.codeUnitAt(0), $.codeUnitAt(0))} }
      ;
    escape =
      | \\ r"d" { {(48, 57)} } // 0-9
      | \\ r"w" { {(64 + 1, 64 + 26), (96 + 1, 96 + 26)} }
      | \\ r"s" { {(9, 13), (32, 32)} }
      ;
    atom = \\ . @1 | !"]" any @1;
  }

  raw = "`" inner:(!"`" . @1)* "`" () {
    StringBuffer buffer = StringBuffer(r"$");

    for (var (int i, String character) in inner.indexed) {
      int unit = character.codeUnits.single;

      if (64 + 1 <= unit && unit <= 64 + 26 || 96 + 1 <= unit && unit <= 96 + 26) {
        buffer.write(character);
      } else {
        buffer.write(unit);
        if (i < inner.length - 1) {
          buffer.write("_");
        }
      }
    }

    return buffer.toString();
  };
}


/// Rules related to general expressions.

dart {
  literal {
    String string = _ (string::main { buffer.substring(from, to) }) _ @1;
    string {
      Object main =
        /// Raw string literals
        | "r" '"""' body:(!'"""' . @1)* '"""'
        | "r" "'''" body:(!"'''" . @1)* "'''"
        | "r" '"'   body:(!'"'   . @1)* '"'
        | "r" "'"   body:(!"'"   . @1)* "'"
        /// Escaped string literals
        | '"""' body:(\\ . @1 | &"$" interpolation | !'"""' . @1)* '"""'
        | "'''" body:(\\ . @1 | &"$" interpolation | !"'''" . @1)* "'''"
        | '"'   body:(\\ . @1 | &"$" interpolation | !'"'   . @1)* '"'
        | "'"   body:(\\ . @1 | &"$" interpolation | !"'"   . @1)* "'"
        ;

      Object interpolation =
        | r"$" "{" balanced "}"
        | r"$" identifier
        ;
      Object balanced = code:(
        | "{" balanced "}" @1
        | !"{" !"}" any @2
      )*;
    }
  }
}

/// Rules related to types declarations.
type {
  String main = raw | nonNullable;
  String nullable    = _ :nonNullable _ `?`? { $3 == null ? "$nonNullable" : "$nonNullable?" };
  String nonNullable = _ (generic | record | base) _ @1;

  /// A record type.
  ///   The fields can be positional or named.
  ///   The fields are separated by commas.
  String record =
    | `(` (`{` fields::named `}` @1)? `)` {
        "(" + ($1 == null ? "" : "{" + $1 + "}") + ")"
      }
    | `(` field::positional `,` (`{` fields::named `}` @1)? `)` {
        "(" + $1 + ", " + ($3 == null ? "" : "{" + $3 + "}") + ")"
      }
    | `(` fields::positional (`,` `{` fields::named `}` @2)? `)` {
        "(" + $1 + ($2 == null ? "" : ", {" + $2 + "}") + ")"
      }
    ;

  String generic = :base `<` :arguments `>` { "$base<$arguments>" };
  String arguments = `,`.nullable+          { $.join(", ") };

  String base = DOT.identifier+ { $.join(".") };

  @fragment fields {
    String positional = `,`.field::positional+ { $.join(", ") };
    String named      = `,`.field::named+      { $.join(", ") };
  }

  @fragment field {
    String positional = nullable _ identifier? { "${$0} ${$2 ?? ""}".trimRight() };
    String named      = nullable _ identifier  { "${$0} ${$2}" };
  }
}

/// Tokens used in the grammar.
///   Since they are not recursive, they are not defined as rules.
@fragment {
  String identifier = [a-zA-Z_$][a-zA-Z\d_$]* { $0 + $1.join() };
  String raw = "`" inner:(!"`" . @1)* "`" { inner.join() };
  int number = \d+ { int.parse($.join()) };

  kw {
    rule      = _ "@rule" _        @1;
    fragment  = _ "@fragment" _    @1;
    start     = _ "startOfInput" _ @1;
    end       = _ "endOfInput" _   @1;
    backslash = _ "backslash" _    @1;
    epsilon   = _ "epsilon" _      @1;
    any       = _ "any" _          @1;
    var       = _ "var" _          @1;
  }

  /// Tokens used in "macro-like" rules.
  mac {
    sep = _ "sep!" _   @1;
  }

  regexEscape {
    backslash       = _ (\\ r"\" { buffer.substring(from, to) }) _ @1;
    digit           = _ (\\ r"d" { buffer.substring(from, to) }) _ @1;
    word            = _ (\\ r"w" { buffer.substring(from, to) }) _ @1;
    space           = _ (\\ r"s" { buffer.substring(from, to) }) _ @1;
    tab             = _ (\\ r"t" { buffer.substring(from, to) }) _ @1;
    formFeed        = _ (\\ r"f" { buffer.substring(from, to) }) _ @1;
    verticalTab     = _ (\\ r"v" { buffer.substring(from, to) }) _ @1;
    null            = _ (\\ r"0" { buffer.substring(from, to) }) _ @1;
    control         = _ (\\ r"c" { buffer.substring(from, to) }) _ @1;
    hex             = _ (\\ r"x" { buffer.substring(from, to) }) _ @1;
    unicode         = _ (\\ r"u" { buffer.substring(from, to) }) _ @1;
    unicodeExtended = _ (\\ r"U" { buffer.substring(from, to) }) _ @1;
    literal         = _ (\\ r"." { buffer.substring(from, to) }) _ @1;
  }

  /// Literal tokens
  `..`  = _ ".." _ @1;
  `::`  = _ "::" _ @1;
  `%%`  = _ "%%" _ @1;
  `=>`  = _ "=>" _ @1;

  `@`   = _ "@"  _ @1;
  `<`   = _ "<"  _ @1;
  `>`   = _ ">"  _ @1;
  `]`   = _ "]"  _ @1;
  `[`   = _ "["  _ @1;
  `}`   = _ "}"  _ @1;
  `{`   = _ "{"  _ @1;
  `)`   = _ ")"  _ @1;
  `(`   = _ "("  _ @1;
  `;`   = _ ";"  _ @1;
  `=`   = _ "="  _ @1;
  `?`   = _ "?"  _ @1;
  `!`   = _ "!"  _ @1;
  `&`   = _ "&"  _ @1;
  `*`   = _ "*"  _ @1;
  `+`   = _ "+"  _ @1;
  `,`   = _ ","  _ @1;
  `:`   = _ ":"  _ @1;
  `|`   = _ "|"  _ @1;

  DOT     = _ "."  _ @1;
  EPSILON = _ "ε"  _ @1;
  CARET   = _ "^"  _ @1;
  DOLLAR  = _ "$"  _ @1;

  /// Layout parser allows comments (like this) and space between parsers.
  _  = (\s | /\/{2}.*(?:(?:\r?\n)|(?:$))/)* { "" };
}