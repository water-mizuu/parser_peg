{

import "package:parser_peg/src/node.dart";
import "package:parser_peg/src/generator.dart";
import "package:parser_peg/src/statement.dart";

final _regexps = (
  from: RegExp(r"\bfrom\b"),
  to: RegExp(r"\bto\b"),
);

}

/// A grammar file contains an optional preamble and statements.
ParserGenerator document = ^ :preamble? statements:_..statement+ _? $ {
  ParserGenerator.fromParsed(preamble: preamble, statements: statements)
};


/// The preamble is simple.
String preamble = `{` _ code:code.curly _ `}` { code };

/// A statement can either be a namespace, a fragment or a rule.
///  A namespace is a collection of statements.
///  A fragment is a declaration that is faster, but doesn't support left recursion / memoization.
///  A rule is a declaration, that supports left recursion & memoization.
Statement statement =
  | namespace
  | fragment
  | inline
  | rule
  ;

/// A namespace is a block of statements which can apply a tag and/or be encapsulated
///   under a name.
Statement namespace =
  | kw.decorator.fragment name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.fragment)
    }
  | kw.decorator.rule name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.rule)
    }
  | kw.decorator.inline name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: Tag.inline)
    }
  | name:identifier? `{` statements:_..statement+ `}` {
      NamespaceStatement(name, statements, tag: null)
    }
  ;


/// A rule is a declaration that supports left recursion & memoization.
/// It can be explicitly stated with a `@rule` keyword, but it is not necessary.
/// It can, however, be useful if it is used inside a `@fragment` tagged namespace.
Statement rule =
  | kw.decorator.rule? kw.var :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? :name :body {
      DeclarationStatement(null, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  | kw.decorator.rule? :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: $0 == null ? null : Tag.rule)
    }
  ;

/// A fragment is a declaration that is called directly, meaning not supporting left recursion / memoization.
/// It can be explicitly stated with a `@fragment` keyword.
Statement fragment =
  | kw.decorator.fragment kw.var :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment :name :body {
      DeclarationStatement(null, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  | kw.decorator.fragment :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: Tag.fragment)
    }
  ;

/// An inline is a declaration that is inlined in the grammar when possible.
/// It can be explicitly stated with a `@inline` keyword.
Statement inline =
  | kw.decorator.inline kw.var :name :body {
      DeclarationStatement(null, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline :name :body {
      DeclarationStatement(null, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline type:(type.main) :name :body {
      DeclarationStatement(type, name, body, tag: Tag.inline)
    }
  | kw.decorator.inline :name `:` type:(type.main) :body {
      DeclarationStatement(type, name, body, tag: Tag.inline)
    }
  ;

/// Shared code between declarations.
@fragment {
  String namespaceReference = (identifier ("::" | !".." ".") !mac @0)* { $.join("::") };
  String namespacedRaw = namespaceReference literal.raw { $0.isEmpty ? $1 : "${$0}::${$1}" };
  String namespacedIdentifier = namespaceReference identifier { $0.isEmpty ? $1 : "${$0}::${$1}" };

  String name = namespacedRaw | namespacedIdentifier;

  Node body = (`=` | `<-` | `->`) :choice `;` { choice };
}

/// A choice parser is a parser that tries to match one of the options.
/// Despite the syntax, the parser is ordered choice.
Node choice =
  | `|`? options:`|`..acted+ { options.length == 1 ? options.single : ChoiceNode(options) };

/// A parser with a bound action.
Node acted =
  /// An empty inline action means that the parser will only return the recognized substring.
  | :sequence `{` `}` {
      InlineActionNode(
        sequence,
        "this.buffer.substring(from, to)",
        areIndicesProvided: true,
      )
    }
  | :sequence `{` _ :code.curly _ `}` {
      InlineActionNode(
        sequence,
        curly.trimRight(),
        areIndicesProvided: curly.contains(_regexps.from) && curly.contains(_regexps.to),
      )
    }
  | :sequence `(` `)` `{` _ :code.curly _ `}` {
      ActionNode(
        sequence,
        curly.trimRight(),
        areIndicesProvided: curly.contains(_regexps.from) && curly.contains(_regexps.to),
      )
    }
  | sequence
  ;

/// A parser that parses a sequence of parsers.
///   By default, a sequence parser returns a [Record] of the results of the parsers.
/// By specifying which item to keep, the specific item can be returned.
Node sequence =
  | body:_..dropped+ chosen:(`@` ~> number)? { body.length == 1 ? body.single : SequenceNode(body, choose: chosen) };

/// A parser that is prefixed or suffixed by another parser.
Node dropped =
  /// The "surround operator".
  ///   (left) ~> (body) <~ (right)
  | left:special `~>` body:labeled `<~` right:special { SequenceNode([left, body, right], choose: 1) }
  /// The "suffix operator".
  ///   (body) <~ (right)
  | body:dropped    `<~` dropped:special { SequenceNode([body, dropped], choose: 1) }
  /// The "prefix operator".
  ///   (body) <~ (right)
  | dropped:special `~>` body:dropped { SequenceNode([dropped, body], choose: 1) }
  | labeled
  ;

/// A parser that adds the label to the declaration of the value.
Node labeled =
  /// The default label. You can label any expression by adding a colon and an identifier.
  /// The label must not have a space before the colon.
  | :identifier ":" _ :special { NamedNode(identifier, special) }

  /// Special cases, where the name can be inferred from the context.
  | ":" id:namespacedIdentifier `?` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, OptionalNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier `*` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, StarNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier `+` { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, PlusNode(ReferenceNode(ref))),
      _ => null,
    } }
  | ":" id:namespacedIdentifier { switch ((id, id.split("::"))) {
      (var ref, [..., var name]) => NamedNode(name, ReferenceNode(ref)),
      _ => null,
    } }
  /// Fallback
  | special
  ;

Node special =
  /// Parsers with a specific count.
  | min:number `..` max:number? body:atom { CountedNode(min, max, body) }
  | :number body:atom                     { CountedNode(number, number, body) }
  /// Pegen style separators.
  | sep:callLike `..` expr:callLike `+` { PlusSeparatedNode(sep, expr, isTrailingAllowed: false) }
  | sep:callLike `..` expr:callLike `*` { StarSeparatedNode(sep, expr, isTrailingAllowed: false) }
  | postfix
  ;

/// A parser that is quantified.
///   Can be nested, but shouldn't be used in practice.
Node postfix =
  /// An optional parser, representing a parser that can be repeated zero or one times.
  | postfix `?` @0 { OptionalNode($) }
  /// Kleene-star, representing a parser that can be repeated zero or more times.
  | postfix `*` @0 { StarNode($) }
  /// Kleene-plus, representing a parser that can be repeated one or more times.
  | postfix `+` @0 { PlusNode($) }
  | prefix
  ;

/// A parser that is prefixed.
///   Usually with disambiguators such as `and-predicate` and `not-predicate`.
Node prefix =
  /// A parser that is only matched if the following parser fails.
  | `~` prefix @1 { SequenceNode([NotPredicateNode($), const AnyCharacterNode()], choose: 1) }
  /// A parser that only returns a boolean, succeeding when the parser succeeds.
  | `&` prefix @1 { AndPredicateNode($) }
  /// A parser that only returns a boolean, succeeding when the parser fails.
  | `!` prefix @1 { NotPredicateNode($) }
  | callLike
  ;

/// "Call"-like because they technically look like a call, but this is special syntax.
///   (Calls don't exist.)
Node callLike =
  /// Flattens a parser result.
  ///   a.flat!()
  | target:callLike `.` mac.flat `(`  `)` {
      InlineActionNode(target, "this.buffer.substring(from, to)", areIndicesProvided: true)
    }
  /// Expects a number of results.
  ///  a.range!(2, 4)
  | target:callLike `.` mac.range `(` min:number `,` max:number `)` { CountedNode(min, max, target) }
  ///  a.range!(2)
  | target:callLike `.` mac.range `(` :number `)`                   { CountedNode(number, number, target) }
  ///  a.range! 2
  | target:callLike `.` mac.range  _  :number  _                    { CountedNode(number, number, target) }
  /// Separates a parser by a separator.
  ///
  ///  a.sep! b
  | sep:callLike `.` mac.sep `(` body:choice `)` `+` `?` { PlusSeparatedNode(sep, body, isTrailingAllowed: true)  }
  | sep:callLike `.` mac.sep `(` body:choice `)` `*` `?` { StarSeparatedNode(sep, body, isTrailingAllowed: true)  }
  | sep:callLike `.` mac.sep `(` body:choice `)` `+`     { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike `.` mac.sep `(` body:choice `)` `*`     { StarSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike `.` mac.sep `(` body:choice `)`         { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | sep:callLike `.` mac.sep  _  body:atom   _          { PlusSeparatedNode(sep, body, isTrailingAllowed: false) }
  | atom
  ;


/// A parser that can be qualified as a group.
///   These are usually parsers that are delimited.
Node atom =
  /// Basic atomic parsers.
  | `(` ~> choice <~ `)`
  /// Special syntax for character classes.
  | (`^` | kw.start)     { const StartOfInputNode() }
  | (`$` | kw.end)       { const EndOfInputNode() }
  | (`.` | kw.any)       { const AnyCharacterNode() }
  | (`ε` | kw.epsilon)   { const EpsilonNode() }
  /// TODO: Add regex backslash symbols.
  | regexEscape.backslash  { const StringLiteralNode(r"\") }

  /// Basics
  | regexEscape.digit      { SimpleRegExpEscapeNode.digit }
  | regexEscape.word       { SimpleRegExpEscapeNode.word }
  | regexEscape.whitespace { SimpleRegExpEscapeNode.whitespace }

  /// Inverses
  | regexEscape.notDigit      { SimpleRegExpEscapeNode.notDigit }
  | regexEscape.notWord       { SimpleRegExpEscapeNode.notWord }
  | regexEscape.notWhitespace { SimpleRegExpEscapeNode.notWhitespace }

  /// Spaces
  | regexEscape.tab            { SimpleRegExpEscapeNode.tab }
  | regexEscape.newline        { SimpleRegExpEscapeNode.newline }
  | regexEscape.carriageReturn { SimpleRegExpEscapeNode.carriageReturn }
  | regexEscape.formFeed       { SimpleRegExpEscapeNode.formFeed }
  | regexEscape.verticalTab    { SimpleRegExpEscapeNode.verticalTab }

  /// Basic literals.
  | literal.range
  | literal.regexp { RegExpNode($) }
  | literal.string { StringLiteralNode($) }
  | name           { ReferenceNode($) }
  ;

code {
  String curly =
    | "`" ~"`"* "`" @1 { $.join() }
    | curly.balanced
    ;

  curly {
    String balanced = code:(
        | dart.literal.string
        | "{" balanced "}" @1 {"{" + $ + "}"}
        | ~("{" | "}")
      )* { code.join() };
  }
}

@fragment literal {
  String regexp = "/" ((\\ . @1 { r"\" + $ } | ~"/")+ { $.join() } ) "/" @1;
  String string = _ string.main _ @1;
  string {
    @inline String main =
      /// Raw string literals
      | 'r"""' ~'"""'* '"""' @1 { $.join() }
      | "r'''" ~"'''"* "'''" @1 { $.join() }
      | 'r"'   ~'"'*   '"'   @1 { $.join() }
      | "r'"   ~"'"*   "'"   @1 { $.join() }
      /// Escaped string literals
      | '"""' (\\ . @1 | ~'"""')* '"""' @1 { $.join() }
      | "'''" (\\ . @1 | ~"'''")* "'''" @1 { $.join() }
      | '"'   (\\ . @1 | ~'"'  )* '"'   @1 { $.join() }
      | "'"   (\\ . @1 | ~"'"  )* "'"   @1 { $.join() }
      ;
  }

  Node range =  _ range.main _ @1;
  range {
    @inline Node main = _ "[" elements:_..element+ "]" _ { RangeNode(elements.reduce((a, b) => a.union(b))) };
    Set<(int, int)> element =
      | escape
      | l:atom "-" r:atom { {(l.codeUnitAt(0), r.codeUnitAt(0))} }
      | atom              { {($.codeUnitAt(0), $.codeUnitAt(0))} }
      ;

    @inline Set<(int, int)> escape =
      | " " { {(32, 32)} } // " "
      | regexEscape.digit { {(48, 57)} } // 0-9
      | regexEscape.word { {(64 + 1, 64 + 26), (96 + 1, 96 + 26)} } // a-z, A-Z
      | regexEscape.whitespace { {(9, 13), (32, 32)} } // \t, \n, \r, \f, \v, space
      | regexEscape.newline { {(10, 10)} }
      | regexEscape.carriageReturn { {(13, 13)} }
      | regexEscape.tab { {(9, 9)} }
      | regexEscape.backslash { {(92, 92)} }
      ;
    String atom = \\ . @1 | ~"]";
  }

  String raw = "`" ~"`"* "`"  @1 { $.join() };
}

/// Rules related to [Dart] expressions.
dart {
  literal {
    /// Since string literals in [Dart] can be put adjacent, we need to parse while
    ///   there are still string literals.
    String string = _..string.body.flat!()+ { $.join(" ") };
    String identifier = global.identifier.flat!();

    string {
      @inline body =
        /// Raw string literals
        | "r" '"""' ~'"""'* '"""' { () }
        | "r" "'''" ~"'''"* "'''" { () }
        | "r" '"'   ~'"'*   '"'   { () }
        | "r" "'"   ~"'"*   "'"   { () }
        /// Escaped string literals
        | '"""' (\\ . @1 | &"$" string.interpolation | ~'"""')* '"""' { () }
        | "'''" (\\ . @1 | &"$" string.interpolation | ~"'''")* "'''" { () }
        | '"'   (\\ . @1 | &"$" string.interpolation | ~'"'  )* '"'   { () }
        | "'"   (\\ . @1 | &"$" string.interpolation | ~"'"  )* "'"   { () }
        ;

      Object interpolation =
        | r"$" "{" balanced "}"
        | r"$" identifier
        ;
      Object balanced = code:("{" balanced "}" @1 | ~("{" | "}"))*;
    }
  }
}

/// Rules related to types declarations.
type {
  String main        = _ ~> raw <~ _ | nonNullable;
  String nullable    = _ :nonNullable _ `?`? { $3 == null ? "$nonNullable" : "$nonNullable?" };
  String nonNullable = _ ~> (generic | record | base) <~ _;

  /// A record type.
  ///   The fields can be positional or named.
  ///   The fields are special by commas.
  String record =
    | `(` (`{` fields.named `}` @1)? `)` {
        "(" + ($1 == null ? "" : "{" + $1 + "}") + ")"
      }
    | `(` field.positional `,` (`{` fields.named `}` @1)? `)` {
        "(" + $1 + ", " + ($3 == null ? "" : "{" + $3 + "}") + ")"
      }
    | `(` fields.positional (`,` `{` fields.named `}` @2)? `)` {
        "(" + $1 + ($2 == null ? "" : ", {" + $2 + "}") + ")"
      }
    ;

  @inline {
    String generic   = :base `<` :arguments `>` { "$base<$arguments>" };
    String arguments = `,`..nullable+   { $.join(", ") };
    String base      = `.`..identifier+ { $.join(".") };
  }

  @fragment fields {
    String positional = `,`..field.positional+ { $.join(", ") };
    String named      = `,`..field.named+      { $.join(", ") };
  }

  @inline field {
    String positional = nullable _ identifier? { "${$0} ${$2 ?? ""}".trimRight() };
    String named      = nullable _ identifier  { "${$0} ${$2}" };
  }
}

/// Tokens used in the grammar.
///   Since they are not recursive, they are not defined as rules.
@fragment {
  String identifier = [a-zA-Z_$][a-zA-Z0-9_$]* { $0 + $1.join() };
  String raw = "`" ~"`"* "`" @1 { $.join() };
  int number = \d+ { int.parse($.join()) };

  kw {
    decorator {
      String rule      = _ "@rule" _        @1;
      String fragment  = _ "@fragment" _    @1;
      String inline    = _ "@inline" _      @1;
    }

    String start     = _ "startOfInput" _ @1;
    String end       = _ "endOfInput" _   @1;
    String backslash = _ "backslash" _    @1;
    String epsilon   = _ "epsilon" _      @1;
    String any       = _ "any" _          @1;
    String var       = _ "var" _          @1;
  }

  String mac =
    | mac.range
    | mac.flat
    | mac.sep
    ;
  /// Tokens used in "macro-like" rules.
  mac {
    String range = _ "range!" _ @1;
    String flat  = _ "flat!"  _ @1;
    String sep   = _ "sep!"   _ @1;
  }

  @inline regexEscape {
    String backslash       = _ ~> (\\ r"\").flat!() <~ _;

    String digit           = _ ~> (\\ r"d").flat!() <~ _;
    String word            = _ ~> (\\ r"w").flat!() <~ _;
    String whitespace      = _ ~> (\\ r"s").flat!() <~ _;

    String notDigit        = _ ~> (\\ r"d").flat!() <~ _;
    String notWord         = _ ~> (\\ r"w").flat!() <~ _;
    String notWhitespace   = _ ~> (\\ r"s").flat!() <~ _;

    String newline         = _ ~> (\\ r"n").flat!() <~ _;
    String carriageReturn  = _ ~> (\\ r"r").flat!() <~ _;
    String tab             = _ ~> (\\ r"t").flat!() <~ _;
    String formFeed        = _ ~> (\\ r"f").flat!() <~ _;
    String verticalTab     = _ ~> (\\ r"v").flat!() <~ _;
    String null            = _ ~> (\\ r"0").flat!() <~ _;
    String control         = _ ~> (\\ r"c").flat!() <~ _;
    String hex             = _ ~> (\\ r"x").flat!() <~ _;
    String unicode         = _ ~> (\\ r"u").flat!() <~ _;
    String unicodeExtended = _ ~> (\\ r"U").flat!() <~ _;
    String literal         = _ ~> (\\ r".").flat!() <~ _;
  }

  /// Literal tokens
  String `..`  = _ ~> ".." <~ _;
  String `::`  = _ ~> "::" <~ _;
  String `%%`  = _ ~> "%%" <~ _;
  String `=>`  = _ ~> "=>" <~ _;
  String `<-`  = _ ~> "<-" <~ _;
  String `->`  = _ ~> "->" <~ _;
  String `~>`  = _ ~> "~>" <~ _;
  String `<~`  = _ ~> "<~" <~ _;

  String `%`   = _ ~> "%" <~ _;
  String `@`   = _ ~> "@" <~ _;
  String `<`   = _ ~> "<" <~ _;
  String `>`   = _ ~> ">" <~ _;
  String `]`   = _ ~> "]" <~ _;
  String `[`   = _ ~> "[" <~ _;
  String `}`   = _ ~> "}" <~ _;
  String `{`   = _ ~> "{" <~ _;
  String `)`   = _ ~> ")" <~ _;
  String `(`   = _ ~> "(" <~ _;
  String `;`   = _ ~> ";" <~ _;
  String `=`   = _ ~> "=" <~ _;
  String `?`   = _ ~> "?" <~ _;
  String `!`   = _ ~> "!" <~ _;
  String `~`   = _ ~> "~" <~ _;
  String `&`   = _ ~> "&" <~ _;
  String `*`   = _ ~> "*" <~ _;
  String `+`   = _ ~> "+" <~ _;
  String `,`   = _ ~> "," <~ _;
  String `:`   = _ ~> ":" <~ _;
  String `|`   = _ ~> "|" <~ _;
  String `/`   = _ ~> "/" <~ _;

  String `.` = _ ~> "." <~ _;
  String `ε` = _ ~> "ε" <~ _;
  String `^` = _ ~> "^" <~ _;
  String `$` = _ ~> "$" <~ _;

  /// Layout parser allows comments (like this) and space between parsers.
  /// Regular Expression monster:
  ///   Split into three parts.
  ///   1. `(?:\s)` - Matches any whitespace character.
  ///   2. `(?:\/{2}.*(?:(?:\r?\n)|(?:$)))` - Matches a single line comment.
  ///   3. `(?:\/\*(?:(?!\*\/).)*\*\/)` - Matches a multi-line comment.
  String _ = /(?:(?:\s)|(?:\/{2}.*(?:(?:\r?\n)|(?:$)))|(?:\/\*(?:(?!\*\/).)*\*\/))*/ { "" };
}
